const drank = {
  color: 'brown',
  corbonated: true,
  sugar: 40
};

//Этот же объект в tuple. TS автоматически определил, что мы работаем
//с тремя типами: string, boolean и number. Проблема втом, что мы 
//можем перепутать порядок свойств значений внутри массива. 
//В tuple очень важен порядок. 

const cola = ['brown', true, 40];

// В примере ниже мы по ошибке поместили значение black во второй аргумент, перезаписав тип boolean

cola[1] = 'black';

//Чтобы этого избежать, в TS есть специальная аннотация, позволяющая нам избежать таких ошибок.
//В этом случае теперь TS сразу сообщит о допущенной ошибке 

const colaTypeAnnotations: [string, boolean, number] = ['brown', true, 40];

//В этом случае теперь TS сразу сообщит о допущенной ошибке 

const colaTypeAnnotations: [string, boolean, number] = ['brown', true, 40];

// TS выдает ошибку, что ожидает тип boolean
colaTypeAnnotations[1] = 'black';

//Вместо кода выше можно использовать такой синтаксис

type Drink = [string, boolean, number]; //это не массив. В данном случае мы создали "type alias"
//Теперь мы можем использовать этот тип в любом месте нашей программы. 


//Вместо всех перечислений, которые мы делали выше, можно просто указать проверку 'type alias' Drink

const colaTypeAnnotations: Drink = ['brown', true, 40];

//Эту проверку можно повторно использовать в других массивах

const sprite: Drink = ['clear', true, 40];
const coffee: Drink = ['black', false, 0];

//Для чего нужны typle и почему мы их будем редко испльзовать.
//Проблема в том, что массив не содержит в себ ключей и трудно
//понять значение указанных чисел

const autoSpecs: [number, number] = [555, 1565];

//А теперь давайте создам объект. В примере ниже мы сразу понимаем
// о чем идет речь.
 
const autoSpecsObj = {
  horsePower: 555,
  weight: 1565
}

//*Вывод: при работе с объектами мы сразу можем понять о чем речь,
//при работе с tuple это не всегда так очевидно если нет дополнительных пояснений.

